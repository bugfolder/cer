<?php

/**
 * @file
 * Install file providing corresponding entity reference schema.
 */

/**
 * Implements hook_schema().
 */
function cer_schema() {
  $schema = array();

  // @see entity_exportable_schema_fields()
  $schema['cer_preset'] = array(
    'fields' => array(
      'pid' => array(
        'type' => 'serial',
        'not null' => TRUE,
      ),
      'identifier' => array(
        'type' => 'text',
        'size' => 'tiny',
        'not null' => TRUE,
        'description' => "The preset's machine-readable export identifier.",
      ),
      'status' => array(
        'type' => 'int',
        'size' => 'tiny',
        'not null' => TRUE,
        'default' => 0x01,  // ENTITY_CUSTOM
        'description' => "The preset's exportable status.",
      ),
      'module' => array(
        'type' => 'varchar',
        'length' => 255,
        'not null' => FALSE,
        'default' => 'cer',
        'description' => 'The module, if any, which exports this preset.',
      ),
    ),
    'primary key' => array('pid'),
  );

  return $schema;
}

/**
 * Implements hook_install().
 */
function cer_install() {
  if (module_exists('corresponding_node_references')) {
    _cer_hijack_cnr();
  }
}

/**
 * Implements hook_uninstall().
 */
function cer_uninstall() {
  state_del('cer_debug');

  // Delete fields created by cer_install()
  field_delete_field('cer_left');
  field_delete_field('cer_right');
  field_delete_field('cer_bidirectional');
  field_delete_field('cer_enabled');
  field_delete_field('cer_weight');
}

/**
 * Converts all CNR presets to CER presets, then disables CNR.
 */
function _cer_hijack_cnr() {
  $cnr = db_query('SELECT * FROM {corresponding_node_references} WHERE 1')->fetchAll();

  foreach ($cnr as $index => $preset) {
    // Prepend 'node*' to each side of the preset. CNR, sensibly enough, assumes everything
    // is on a node, but CER needs this specified explicitly.
    $key = explode('*', $preset->node_types_content_fields);
    $cnr[$index]->entity_types_content_fields = "node*{$key[0]}*{$key[1]}*node*{$key[2]}*{$key[3]}";
  }
  array_walk($cnr, '_cer_rebuild_preset');

  module_disable(array('corresponding_node_references'));
  backdrop_set_message(t('Rebuilt CNR presets.'));
}

/**
 * Implements hook_update_last_removed.
 */
function cer_update_last_removed() {
  return 7005;
}

/**
 * Update D7 variable to config for CER.
 */
function cer_update_1000() {
  config_set('cer.settings', 'cer_enable_field_ui', update_variable_get('cer_enable_field_ui', FALSE));
  update_variable_del('cer_enable_field_ui');
}

/**
 * Rebuilds a legacy CER or CNR preset as a CerPreset entity.
 */
function _cer_rebuild_preset($old) {
  if (isset($old->entity_types_content_fields)) {
    $keys = explode('*', $old->entity_types_content_fields);

    $old->a = implode(':', array_slice($keys, 0, 3));
    $old->b = implode(':', array_slice($keys, 3));
  }
  if (! isset($old->bidirectional)) {
    $old->bidirectional = TRUE;
  }
  if (! isset($old->weight)) {
    $old->weight = 0;
  }
  // If the 'enabled' flag doesn't exist, we can presume that this preset
  // was exported in code generated by CTools, which means that it should
  // have a 'disabled' flag, which we can invert to get the status.
  if (! isset($old->enabled)) {
    $old->enabled = (! $old->disabled);
  }

  // Validate both field chains by trying to unpack them. If any field in
  // either chain isn't exposed by hook_cer_fields(), an exception will be
  // thrown and we can bail out with an error message.
  try {
    CerFieldChain::unpack($old->a);
    CerFieldChain::unpack($old->b);
  }
  catch (Exception $e) {
    $variables = array(
      '%key' => "{$old->a}*{$old->b}",
    );
    return backdrop_set_message(t('Could not rebuild preset %key because it refers to invalid fields.', $variables), 'error');
  }

  $preset = new CerPreset();
  $preset->wrapper->cer_left->set($old->a);
  $preset->wrapper->cer_right->set($old->b);
  $preset->wrapper->cer_enabled->set($old->enabled);
  $preset->wrapper->cer_bidirectional->set($old->bidirectional);
  $preset->wrapper->cer_weight->set($old->weight);
  $preset->save();
}
